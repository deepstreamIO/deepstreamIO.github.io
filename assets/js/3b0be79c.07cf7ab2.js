"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[314],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>g});var i=t(6540);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=i.createContext({}),s=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=s(e.components);return i.createElement(c.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(t),h=o,g=d["".concat(c,".").concat(h)]||d[h]||u[h]||a;return t?i.createElement(g,r(r({ref:n},p),{},{components:t})):i.createElement(g,r({ref:n},p))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=h;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<a;s++)r[s]=t[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},9574:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=t(8168),o=(t(6540),t(5680));const a={title:"Connectivity"},r=void 0,l={unversionedId:"tutorials/concepts/connectivity",id:"tutorials/concepts/connectivity",title:"Connectivity",description:"All deepstream SDKs establish a persistent, bidirectional connection to the platform. This connection can be lost due to network outage, lack of mobile network coverage or similar problems \u2013 if this happens all SDKs will queue outgoing updates and try to re-establish the connection.",source:"@site/docs/00-tutorials/00-concepts/20-connectivity.md",sourceDirName:"00-tutorials/00-concepts",slug:"/tutorials/concepts/connectivity",permalink:"/docs/tutorials/concepts/connectivity",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/docs/00-tutorials/00-concepts/20-connectivity.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Connectivity"},sidebar:"tutorialSidebar",previous:{title:"What is deepstream?",permalink:"/docs/tutorials/concepts/what-is-deepstream"},next:{title:"Security Overview",permalink:"/docs/tutorials/concepts/security"}},c=[{value:"Reconnection behaviour",id:"reconnection-behaviour",children:[],level:2},{value:"Heartbeats",id:"heartbeats",children:[],level:2},{value:"Connection States",id:"connection-states",children:[{value:"OPEN",id:"open",children:[],level:3},{value:"RECONNECTING",id:"reconnecting",children:[],level:3},{value:"CLOSED",id:"closed",children:[],level:3},{value:"ERROR",id:"error",children:[],level:3},{value:"OFFLINE",id:"offline",children:[],level:3},{value:"AWAITING_CONNECTION",id:"awaiting_connection",children:[],level:3},{value:"CHALLENGING",id:"challenging",children:[],level:3},{value:"AWAITING_AUTHENTICATION",id:"awaiting_authentication",children:[],level:3},{value:"AUTHENTICATING",id:"authenticating",children:[],level:3}],level:2},{value:"An Example",id:"an-example",children:[],level:2},{value:"Closed client connection",id:"closed-client-connection",children:[],level:2}],s={toc:c},p="wrapper";function d(e){let{components:n,...t}=e;return(0,o.yg)(p,(0,i.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"All deepstream SDKs establish a persistent, bidirectional connection to the platform. This connection can be lost due to network outage, lack of mobile network coverage or similar problems \u2013 if this happens all SDKs will queue outgoing updates and try to re-establish the connection."),(0,o.yg)("h2",{id:"reconnection-behaviour"},"Reconnection behaviour"),(0,o.yg)("p",null,"If a connection is lost, the client will immediately attempt to reconnect. Should that fail, it will wait a certain time and retry. Upon every unsuccessful attempt it will increment the time until the next attempt is made by a number of milliseconds specified in ",(0,o.yg)("inlineCode",{parentName:"p"},"reconnectIntervalIncrement"),". For example if this is set to ",(0,o.yg)("inlineCode",{parentName:"p"},"2000")," the first reconnection attempt will be made immediately, the second after two seconds, the next four seconds after that and so on. You can specify an upper limit to this as ",(0,o.yg)("inlineCode",{parentName:"p"},"maxReconnectInterval"),". After a number of unsuccessful attempts configurable as ",(0,o.yg)("inlineCode",{parentName:"p"},"maxReconnectAttempts")," the client will give up and change the connection-state to ",(0,o.yg)("inlineCode",{parentName:"p"},"ERROR"),"."),(0,o.yg)("h2",{id:"heartbeats"},"Heartbeats"),(0,o.yg)("p",null,"Even if your connection is established, messages might not arrive. To check this, clients continuously send small ping-messages to the platform to make sure it\u2019s still reachable. If the client misses two consecutive responses it will change the connection-state to ",(0,o.yg)("inlineCode",{parentName:"p"},"ERROR")," regardless of connectivity. You can configure how frequently these heartbeat messages are sent via ",(0,o.yg)("inlineCode",{parentName:"p"},"heartbeatInterval")," (every 30 seconds by default)."),(0,o.yg)("h2",{id:"connection-states"},"Connection States"),(0,o.yg)("p",null,"Each SDK provides the current connection-state as well as a way to listen for changes."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Connected")),(0,o.yg)("h3",{id:"open"},"OPEN"),(0,o.yg)("p",null,"The connection is established; everything is fine."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Not Connected")),(0,o.yg)("h3",{id:"reconnecting"},"RECONNECTING"),(0,o.yg)("p",null,"The connection was lost to server. The client makes reconnection attempts."),(0,o.yg)("h3",{id:"closed"},"CLOSED"),(0,o.yg)("p",null,"The connection was deliberately closed by the user via ",(0,o.yg)("inlineCode",{parentName:"p"},"client.close()"),". No reconnection attempts will be made. The client also starts in this state, but almost immediatly switches to ",(0,o.yg)("inlineCode",{parentName:"p"},"AWAITING_CONNECTION"),"."),(0,o.yg)("h3",{id:"error"},"ERROR"),(0,o.yg)("p",null,"The connection is finally declared unrecoverable, e.g. as a result from too many failed reconnection attempts or missed heartbeats. No further reconnection attempts will be made."),(0,o.yg)("h3",{id:"offline"},"OFFLINE"),(0,o.yg)("p",null,"The client deliberately  disconnected from the server using the ",(0,o.yg)("inlineCode",{parentName:"p"},"pause()")," method. Can be reconnected using the ",(0,o.yg)("inlineCode",{parentName:"p"},"resume()")," method."),(0,o.yg)("p",null,(0,o.yg)("strong",{parentName:"p"},"Intermediate States")),(0,o.yg)("h3",{id:"awaiting_connection"},"AWAITING_CONNECTION"),(0,o.yg)("p",null,"The client has established the physical connection and waits for the initial response from the server."),(0,o.yg)("h3",{id:"challenging"},"CHALLENGING"),(0,o.yg)("p",null,"The client is currently undergoing a negotiation sequence that might result in a redirect or exchange of configuration."),(0,o.yg)("h3",{id:"awaiting_authentication"},"AWAITING_AUTHENTICATION"),(0,o.yg)("p",null,"State after the client was initialised, but before ",(0,o.yg)("inlineCode",{parentName:"p"},".login()")," was called."),(0,o.yg)("h3",{id:"authenticating"},"AUTHENTICATING"),(0,o.yg)("p",null,"State after ",(0,o.yg)("inlineCode",{parentName:"p"},".login()")," was called, but before the response from the platform is received."),(0,o.yg)("h2",{id:"an-example"},"An Example"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},"const options = {\n    // Reconnect after 10, 20 and 30 seconds\n    reconnectIntervalIncrement: 10000,\n    // Try reconnecting every thirty seconds\n    maxReconnectInterval: 30000,\n    // We never want to stop trying to reconnect\n    maxReconnectAttempts: Infinity,\n    // Send heartbeats only once a minute\n    heartbeatInterval: 60000\n};\n\nconst client = new DeepstreamClient('<url>', options)\nclient.login()\n\n// Assume we're updating a green/yellow/red indicator for connectionState with jQuery\nconst connectionStateIndicator = $('#connection-state-indicator');\nclient.on('connectionStateChanged', connectionState => {\n    connectionStateIndicator.removeClass('good neutral bad')\n    switch (connectionState) {\n        case 'OPEN':\n            connectionStateIndicator.addClass('good')\n            break\n        case 'CLOSED':\n        case 'ERROR':\n            connectionStateIndicator.addClass('bad')\n            break\n        default:\n            connectionStateIndicator.addClass('neutral')\n    }\n})\n")),(0,o.yg)("h2",{id:"closed-client-connection"},"Closed client connection"),(0,o.yg)("p",null,"Once the client closes the connection to the server calling the ",(0,o.yg)("inlineCode",{parentName:"p"},"close()")," method, it can not be opened again using the same instance of the client. This can cause some issues on web/mobile when we logout a user, and close it's deepstream client connection, and then try to login as a new user. It will not be possible using the same instance of the client. One solution is to use the ",(0,o.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Singleton_pattern"},"singleton pattern"),", as shown in this quick example:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},"\n// Deepstream client using \"singleton\" pattern\nlet client = null\n\nconst dsClient = () => {\n  if (!client) {\n    client = new DeepstreamClient('<url>', options)\n  }\n  if (client && client.getConnectionState() === 'CLOSED') {\n    client = new DeepstreamClient('<url>', options)\n  }\n  return client\n}\n")),(0,o.yg)("p",null,"Then pass along and call the dsClient function for interacting with the client methods:\n",(0,o.yg)("inlineCode",{parentName:"p"},"dsClient().login()"),"\n",(0,o.yg)("inlineCode",{parentName:"p"},"dsClient().record.getRecord(recordName)")),(0,o.yg)("p",null,"Using this pattern, if the client connection is closed, a new one will be instantiated and returned."))}d.isMDXComponent=!0}}]);