"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[3320],{3905:function(e,t,a){a.d(t,{Zo:function(){return u},kt:function(){return d}});var n=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(a),d=s,m=p["".concat(l,".").concat(d)]||p[d]||h[d]||r;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function d(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,o=new Array(r);o[0]=p;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<r;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},6935:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return u},toc:function(){return h},default:function(){return d}});var n=a(7462),s=a(3366),r=(a(7294),a(3905)),o=["components"],i={title:"Realtime Search",description:"The Realtime Search Evolution",blogImage:"/images/elton/elton-professor.png"},l=void 0,c={permalink:"/blog/2019/11/04/realtime-search",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/blog/2019-11-04-realtime-search.md",source:"@site/blog/2019-11-04-realtime-search.md",title:"Realtime Search",description:"The Realtime Search Evolution",date:"2019-11-04T00:00:00.000Z",formattedDate:"November 4, 2019",tags:[],readingTime:9.1,truncated:!1,authors:[]},u={authorsImageUrls:[]},h=[{value:"Important",id:"important",children:[],level:3},{value:"HTTP Requests",id:"http-requests",children:[],level:3},{value:"Push Notifications / Events",id:"push-notifications--events",children:[],level:3},{value:"Static Result Notifications",id:"static-result-notifications",children:[],level:3},{value:"Dynamic Result Notifications",id:"dynamic-result-notifications",children:[{value:"Pros",id:"pros",children:[],level:4},{value:"Cons",id:"cons",children:[],level:4}],level:3},{value:"Dynamic Result Notifications Using Deepstream",id:"dynamic-result-notifications-using-deepstream",children:[],level:3},{value:"Realtime Search, Finally!",id:"realtime-search-finally",children:[],level:3}],p={toc:h};function d(e){var t=e.components,a=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Realtime Search is one of the most powerful realtime concepts out there, and have been slowly been finding themselves in modern applications, regardless of the underlying technology backing it."),(0,r.kt)("p",null,"We are proud to announce a new realtime-search process that runs next to deepstream, allowing users to create realtime functionality with barely any code, and with an extensible plugin architecture to support more databases in the future!"),(0,r.kt)("p",null,"We'll begin our journey from a static HTTP request and end with the functionality provided\nby deepstream and the realtime-search component. You can also skip to the ",(0,r.kt)("a",{parentName:"p",href:"#realtime-search-finally"},"last section")," if this is just too long!"),(0,r.kt)("h3",{id:"important"},"Important"),(0,r.kt)("p",null,"The code presented in these examples is pseudo code which I haven't run, and have some helper functions\nto minimize eye strain"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"doQuery"))),(0,r.kt)("p",null,"Is what you would call to run a single query against your database, which would return the results as an array"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"makeRequest"))),(0,r.kt)("p",null,"Is what you would call to make a HTTP request in your application, like a GET or POST"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"doSomethingWithData"))),(0,r.kt)("p",null,"What your application would call once your data is loaded"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"database.table('users').on"))),(0,r.kt)("p",null,"Is similar to mongodb changefeeds, which tells you whenever a table has been updated"),(0,r.kt)("h3",{id:"http-requests"},"HTTP Requests"),(0,r.kt)("p",null,"The most common technique is to perform a search is a HTTP GET with search parameters / POST with a body. It scales amazingly well with any deployment platform out there, caches results and just works."),(0,r.kt)("p",null,"Service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"server.on('/search', async (req, res) => {\n    const results = await doQuery(req)\n    res.send(results)\n})\n")),(0,r.kt)("p",null,"Client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"setInterval (() => {\n    const result = await makeRequest('/search')\n    doSomethingWithData(result)\n}, 1000)\n")),(0,r.kt)("p",null,"If you want to make your application update without having to refresh, you can just rerequest the data, either when a user\nperforms a refresh action or on a set interval."),(0,r.kt)("h3",{id:"push-notifications--events"},"Push Notifications / Events"),(0,r.kt)("p",null,"Once you have an application that can load data-dynamically, you can go one step further and add an extremely simple push layer to allow your application to be told whenever data needs to be refreshed. This allows you to continue using all the benefits of a normal HTTP application (scalability and so forth) while also getting told when to update to\nprovide quicker updates to the end user and ideally reduce the amount of polling."),(0,r.kt)("p",null,"Service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"server.on('/search', async (req, res) => {\n    const results = await doQuery()\n    res.send(results)\n})\n\n// Emit an event whenever the client changes (pseduo code based on changelogs)\ndatabase.table('users').on('change', () => {\n  deepstream.event.emit('users-changed')\n})\n")),(0,r.kt)("p",null,"Client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// Subscribe to the event on the client and redo query\ndeepstream.event.subscribe('users-changed', doSomethingWithData)\n// Do query initially to get results\nconst results = await makeRequest('/search')\ndoSomethingWithData(results)\n")),(0,r.kt)("p",null,"Pretty useful right? This means our users no longer have to request data manually, wait for a certain timeout, extensively  poll your systems (which does get a little expensive with large deployments and cloud providers) and you can still lean back on using your normal HTTP stack for development."),(0,r.kt)("h3",{id:"static-result-notifications"},"Static Result Notifications"),(0,r.kt)("p",null,"Blindly getting told that a table changed however is still an extremely coarse action, specially the larger your table gets. You would most likely want to add some form of smarter caching so that users only get told if they really care about something."),(0,r.kt)("p",null,"Luckily if you have static application queries this is actually quite easy!"),(0,r.kt)("p",null,"Service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"server.on('/static-search', async (req, res) => {\n    const results = await doQuery()\n    res.send(results)\n})\n\n// Emit an event whenever the client changes (pseduo code based on changelogs)\nconst specificQueryUpdates = () => {\n    let previousResults\n    database.table('users').on('change', await () => {\n        const results = await doQuery()\n        if (!deepEquals(previousResults, results)) {\n            deepstream.event.emit('specific-query-changed', results)\n        }\n        previousResults = results\n    })\n}\n")),(0,r.kt)("p",null,"Client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// Subscribe to an event on the client\ndeepstream.event.subscribe('specific-query-changed', doSomethingWithData)\n// We still need to get the data initially though, as events are only triggered\n// on changes\nconst results = await makeRequest('/static-search')\ndoSomethingWithData(results)\n")),(0,r.kt)("p",null,"This means we now have the ability to subscribe to a specific query event and just receive updates. The advantage\nof this is that if you have a thousand users connected, the query is still only run once and the result is sent to\nall of them, which makes it much more efficient. The disadvantages so far is the static nature of the event means we can't really do our own custom queries, and that we have to do the event initially which means we have to maintain two different types of APIs. Not cool."),(0,r.kt)("h3",{id:"dynamic-result-notifications"},"Dynamic Result Notifications"),(0,r.kt)("p",null,"So how can we let the backend know to setup an endpoint for a custom query, maintain it\nduring the queries lifetime and then when it's no longer needed discard it? \ud83e\udd14 There are different solutions, but the one we see most often is:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Request a query by telling the client to start"),(0,r.kt)("li",{parentName:"ul"},"Get updates"),(0,r.kt)("li",{parentName:"ul"},"Discard it when your done")),(0,r.kt)("p",null,"In a classical event system this would usually be done as follows (for this example you need to have sticky sessions available in order for the close event to go the same process as the open one)"),(0,r.kt)("p",null,"Service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const searches = new Map()\n\nserver.post('/start-search', async (req, res) => {\n    // Hash the query so that you can use it as a lookup key\n    const searchReference = hashSearch(req.body)\n    let search = searches.has(searchReference)\n\n    // If the query already exists, someone already started it, so\n    // bump up the usage number and return the last results\n    if (searches.has(searchReference)) {\n        const search = searches.get(searchReference)\n        search.usage = search.usage + 1\n        return res.send({\n            reference: search.reference,\n            data: search.previousResult\n        })\n    }\n\n    // Setup the cursor\n    const cursor = database.table(req.body.table).on('change', await () => {\n        const results = await doQuery(req.body.query)\n        if (!deepEquals(search.previousResults, results)) {\n            deepstream.event.emit(searchReference, results)\n        }\n        search.previousResults = results\n    })\n\n    // Set the search so new requests won't setup another cursor\n    searches.set(searchReference, {\n        usage: 1,\n        reference: searchReference,\n        cursor\n    })\n\n    // Do the actual initial search to avoid it having to be done on the\n    // client side\n    const results = await doQuery()\n\n    // Send the response\n    res.send({\n        reference: search.reference,\n        data: results\n    })\n})\n\nserver.post('/stop-search', async (req, res) => {\n    const { reference } = req.body\n    const search = searches.get(references)\n    if (search) {\n        search.usages = search.usages - 1\n        if (search.usages === 0) {\n            searches.del(reference)\n            search.cursor.stop()\n        }\n        return res.end()\n    }\n    res.status(400).end()\n})\n")),(0,r.kt)("p",null,"Client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// Creating the search\nconst { reference, data } = makeRequest('/start-search', { query: [['age','gt', '20']], table: 'users' })\ndeepstream.event.subscribe(reference, doSomethingWithData)\ndoSomethingWithData(data)\n\n// Ending the search\ndeepstream.event.unsubscribe(reference)\nmakeRequest('/stop-search', { reference })\n")),(0,r.kt)("p",null,"Okay so that's alot of code. Probably a good place to stop before writing an actual service. Let us break down the pros and cons of this approach (ignoring potential bugs due to pseudo nature!):"),(0,r.kt)("h4",{id:"pros"},"Pros"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Minimal amount of cursors open"),(0,r.kt)("li",{parentName:"ul"},"Basic lifecycle support means that if the clients always cleaned up after themselves system can go back to\noriginal state"),(0,r.kt)("li",{parentName:"ul"},"We can proxy multiple realtime search queries easily. Not very useful for infinite permutations (like text searches) but if your search is limited or you have built in default searches (like pagination or limits) it would scale well")),(0,r.kt)("h4",{id:"cons"},"Cons"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you want to scale you'll need to attach to a third party cache/database (the norm nowadays for distributed/scaling systems)"),(0,r.kt)("li",{parentName:"ul"},"You can call start-search / end-search multiple times and it would get the state out of sync"),(0,r.kt)("li",{parentName:"ul"},"Most importantly, since its not really tied into the session if your connection drops or you force close your client\nstate is incorrect")),(0,r.kt)("h3",{id:"dynamic-result-notifications-using-deepstream"},"Dynamic Result Notifications Using Deepstream"),(0,r.kt)("p",null,"Right so now we are going to rewrite the above code using deepstream APIs. I'll be using ",(0,r.kt)("inlineCode",{parentName:"p"},"listening"),", a powerful API that allows deepstream to notify clients/services whenever a subscription has been added or removed to the system, which removes most of the boiler plate management. I'll also be using RPCs and Records, mainly because it removes us having to use HTTP and automatically saves things in the cache. It's also 95% of the way to explaining how the realtime-search was built."),(0,r.kt)("p",null,"Service:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"deepstream.rpc.provide('realtime_search', async (data, response) => {\n    const hash = hashSearch(data)\n    try {\n        await deepstream.record.set(hash, data)\n        response.send()\n    } catch (e) {\n        response.error('Error creating a hash')\n    }\n})\n\ndeepstream.record.listen('realtime_search/list_.*', async (name, response) => {\n    const hash = /realtime_search\\/list_(.*)/.match(name)[0]\n    const data = await deepstream.record.snapshot(hash)\n\n    const cursor = database.table(data.table).on('change', async () => {\n        const results = await doQuery(data.query)\n        const previousResults = await deepstream.record.snapshot(name)\n        if (!deepEquals(previousResults, results)) {\n            deepstream.record.setData(name, results)\n        }\n    })\n\n    const results = await doQuery()\n    deepstream.record.setData(name, results)\n\n    response.onStop(() => cursor.stop())\n    response.accept()\n})\n")),(0,r.kt)("p",null,"Client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"// Creating the search\nconst hash = await client.rpc.make('realtime_search', { query: [['age','gt', '20']], table: 'users' })\nconst record = client.record.getRecord(`realtime_search/list_${hash}`)\nrecord.subscribe((results) => {\n    // do something with results\n}, true)\n\n// Ending the search\nrecord.discard()\n")),(0,r.kt)("p",null,"Let us see what cons this managed to resolve:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Scaling")),(0,r.kt)("p",null,"Listening on deepstream uses an active publisher pattern. This means only one service in a cluster can ever\nbe responsible for a subscription. This means you can scale your services and servers and the load will automatically be\ndistributed against them."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Cache/Storage")),(0,r.kt)("p",null,"Using deepstream records we automatically have our data saved to cache. This means by using it we get the benefit\nof distributed state out of the box, so if another user subscribes to the same record the micro service won't even need to be told about it"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"State")),(0,r.kt)("p",null,"All the connection state and logic is handled by deepstream, which means if your client goes down, deepstream will\nclean up all your subscriptions on your behalf. This allows the platform to continue running optimally. So state getting out of sync isn't your concern"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Hint")),(0,r.kt)("p",null,"The listen pattern can be used for so much more than just this usecase!"),(0,r.kt)("h3",{id:"realtime-search-finally"},"Realtime Search, Finally!"),(0,r.kt)("p",null,"Okay I really hope you made it this far! Let's look at how realtime-search APIs work."),(0,r.kt)("p",null,"On the server we don't need to actually write any server code, you just have to run the realtime-search service. You can run it via docker ",(0,r.kt)("a",{parentName:"p",href:"https://hub.docker.com/r/deepstreamio/realtime-search"},"deepstreamio/realtime-search"),", but it's also shipped via node under the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@deepstream/realtime-search"},"@deepstream/realtime-search")," package."),(0,r.kt)("p",null,"We will be following the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/deepstreamIO/deepstream.io-realtime-search/tree/master/example"},"example found in the github repo"),". This will use docker compose, which is useful as we need to setup a mongodb replica as well as run deepstream and the realtime-search service for us."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/deepstreamIO/deepstream.io-realtime-search.git\ncd deepstream.io-realtime-search/example\ndocker-compose up\n")),(0,r.kt)("p",null,"Giving us the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'11:53:13 AM | Initializing MongoDB Connection\n11:53:13 AM | Connected successfully to mongodb database deepstream\n11:53:13 AM | Initializing Deepstream connection\n11:53:13 AM | Successfully logged in to deepstream\n11:53:13 AM | Providing rpc method "realtime_search"\n11:53:13 AM | listening for realtime_search/list_.*\n11:53:13 AM | realtime search provider ready\n')),(0,r.kt)("p",null,"And then on the client side you would just need to do the same thing we mentioned earlier:"),(0,r.kt)("p",null,"Client:\n",(0,r.kt)("inlineCode",{parentName:"p"},"embed:server/realtime-search/example/realtime-search-client.js")),(0,r.kt)("p",null,"And that's it! As you can see getting realtime-results couldn't be easier."),(0,r.kt)("p",null,"For a front-end example, more config options and permissions please checkout the ",(0,r.kt)("a",{parentName:"p",href:"../docs/20-guides/realtime-search/00-intro.md"},"realtime-search guide"),"."),(0,r.kt)("p",null,"Thanks for reading!"))}d.isMDXComponent=!0}}]);