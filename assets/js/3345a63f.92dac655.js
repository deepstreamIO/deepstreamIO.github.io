"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[2997],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return h}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(r),h=o,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||i;return r?n.createElement(m,a(a({ref:t},u),{},{components:r})):n.createElement(m,a({ref:t},u))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=r.length,a=new Array(i);a[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=r[c];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},6680:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var n=r(7462),o=r(3366),i=(r(7294),r(3905)),a=["components"],s={title:"WebRTC in production",description:"Learn about the various approaches to video and audio streaming, connection re-establishment, file chunking etc. that are necessary for production ready WebRTC apps",tags:["WebRTC","production","SFU","Chunking"]},l=void 0,c={unversionedId:"guides/webrtc/webrtc-in-production",id:"guides/webrtc/webrtc-in-production",title:"WebRTC in production",description:"Learn about the various approaches to video and audio streaming, connection re-establishment, file chunking etc. that are necessary for production ready WebRTC apps",source:"@site/docs/20-guides/webrtc/70-webrtc-in-production.md",sourceDirName:"20-guides/webrtc",slug:"/guides/webrtc/webrtc-in-production",permalink:"/docs/guides/webrtc/webrtc-in-production",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/docs/20-guides/webrtc/70-webrtc-in-production.md",tags:[{label:"WebRTC",permalink:"/docs/tags/web-rtc"},{label:"production",permalink:"/docs/tags/production"},{label:"SFU",permalink:"/docs/tags/sfu"},{label:"Chunking",permalink:"/docs/tags/chunking"}],version:"current",sidebarPosition:70,frontMatter:{title:"WebRTC in production",description:"Learn about the various approaches to video and audio streaming, connection re-establishment, file chunking etc. that are necessary for production ready WebRTC apps",tags:["WebRTC","production","SFU","Chunking"]},sidebar:"tutorialSidebar",previous:{title:"WebRTC 06: File Transfer",permalink:"/docs/guides/webrtc/webrtc-file-transfer"}},u=[{value:"Browser Limitations",id:"browser-limitations",children:[],level:2},{value:"Connectivity",id:"connectivity",children:[],level:2},{value:"Video Streaming",id:"video-streaming",children:[],level:2},{value:"MCU or SFU?",id:"mcu-or-sfu",children:[],level:2},{value:"File Transfers",id:"file-transfers",children:[],level:2},{value:"Where to go from here",id:"where-to-go-from-here",children:[],level:2}],d={toc:u};function p(e){var t=e.components,r=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Time for some bad news. The examples from the previous tutorials probably worked well on your machine. They most likely still worked well when you shared them with a few colleagues within your company. But for scalable, world wide WebRTC usage there are quite a few more obstacles to overcome"),(0,i.kt)("h2",{id:"browser-limitations"},"Browser Limitations"),(0,i.kt)("p",null,"WebRTC is ",(0,i.kt)("a",{parentName:"p",href:"https://caniuse.com/#search=webrtc"},"supported by latest versions of Chrome, Firefox and IE Edge"),", but not in Safari or a number of mobile browsers. With most browser-standards that would simply mean falling back to other mechanisms, but with WebRTC this is hardly possible. Older alternatives such as ",(0,i.kt)("a",{parentName:"p",href:"https://de.wikipedia.org/wiki/Real_Time_Messaging_Protocol"},"Flash's RTMP")," are unsupported by the exact same browsers that don't provide WebRTC either. As a result a number of video-conferencing vendors use WebRTC as default, but continue to offer downloadable clients for cases where its unavailable."),(0,i.kt)("h2",{id:"connectivity"},"Connectivity"),(0,i.kt)("p",null,'One of the main obstacles when it comes to establishing WebRTC connections is a technique called Network Address Translation or NAT for short. NAT is used by routers, internet service providers or larger companies to bundle multiple endpoints behind a single public IP and route traffic to them. This makes it hard for two peers to connect directly to each other. To circumvent that we can use an approach called "Traversal Using Relays around NAT" or TURN for short. Fortunately there\'s a number of ',(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/sagivo/3a4b2f2c7ac6e1b5267c2f1f59ac6c6b"},"publicly accessible STUN and TURN servers"),". To use a TURN server just specify its URL in the options for the ",(0,i.kt)("inlineCode",{parentName:"p"},"RTCPeerConnection")," constructor, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"}," { iceServers: [ { url: 'stun:stun.l.google.com:19302' } ] }")),(0,i.kt)("p",null,"Once your connection is established it will still drop occasionally. That might be due to dodgy network conditions, too many open background tabs or any number of other reasons. That's not much of a problem as long as you make sure to keep track of each connection's state and reconnect as soon as it drops."),(0,i.kt)("h2",{id:"video-streaming"},"Video Streaming"),(0,i.kt)("p",null,"If you have ever used a video conferencing service you'll know one thing: reliable video and audio streaming is still an unsolved problem. WebRTC is no different. Building a peer-to-peer video conferencing app sounds tempting: There's no central server that can go down and no high traffic costs. But it is something that's almost never done in production."),(0,i.kt)("p",null,"The reasons are manifold. Users have widely differing input and output requirements. Different webcams provide different resolutions, framerates and qualities, which need to be displayed on a myriad of screen and window sizes."),(0,i.kt)("p",null,"Bandwith plays an even more important role. A compressed HD stream requires around 5 Mbit/second. In a full mesh P2P video conference with 10 attendees each node would need to send and receive 50 Mbit/second - unachievable with the upload speeds that most ISP's provide."),(0,i.kt)("p",null,'This means that for almost all WebRTC video streaming apps the "peer" is in fact a piece of server hardware or software, either an MCU or a SFU.'),(0,i.kt)("h2",{id:"mcu-or-sfu"},"MCU or SFU?"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Multipoint_control_unit"},"MCU (Multipoint Control Unit)")," is a technology that consumes one or more video-streams, composes them into a single stream and forwards it to many endpoints. It can also provide additional tasks such as video processing, changing resolution on the fly or generating keyframes and deltas for video compression."),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://webrtcglossary.com/sfu/"},"SFU (Selective Forwarding Unit)")," offers similar functionality, but forwards the individual streams upon request."),(0,i.kt)("p",null,"So what's the difference? Imagine your on a conference call with 20 people, all using different webcams and monitors. With a SFU you get 20 pre-processes streams that need handling. A MCU however gives you a single, well orchestratet stream with what you need to actually display on the screen rather than leaving the heavy lifting to the client."),(0,i.kt)("p",null,"Sound awesome, right? The truth though is that SFUs are increasingly becoming the standard. MCUs need to decode each video, resize and reformat it and compose a new frame on every update - this is very computation heavy and requires extremely expensive hardware - especially of the advent of HD, 4k and even 8k displays."),(0,i.kt)("p",null,"Clients, even browsers have however become fast enough to handle quite a lot of computation - so forwarding streams directly using an SFU is often completely sufficient."),(0,i.kt)("h2",{id:"file-transfers"},"File Transfers"),(0,i.kt)("p",null,"File transfers can be equally tricky. WebRTC gives developers a choice of ordered and reliable TCP style, unordered or unreliable UDP style communication. To efficiently transfer files it makes sense to use an unordered, yet reliable model and optimise speed on a byte level. This also makes it possible to receive parts of a file from multiple peers at once, speeding up downloads significantly."),(0,i.kt)("p",null,"This does however also mean that its up to the implementation to ensure file integrity using checksums. Another hard limitation is the fact that browsers store the incoming file data in memory - which creates a hard limit to the maximum filesize that can be transferred."),(0,i.kt)("h2",{id:"where-to-go-from-here"},"Where to go from here"),(0,i.kt)("p",null,"I hope this guide - despite all its warnings and pitfalls - motivated you to give WebRTC a go for your next application. To learn more about WebRTC production usecases, have a look at ",(0,i.kt)("a",{parentName:"p",href:"https://webrtchacks.com/"},"WebRTCHacks"),"."))}p.isMDXComponent=!0}}]);