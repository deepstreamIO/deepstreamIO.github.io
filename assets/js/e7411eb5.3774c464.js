"use strict";(self.webpackChunkdeepstream_io_website=self.webpackChunkdeepstream_io_website||[]).push([[3752],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return p}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(r),p=a,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||i;return r?n.createElement(m,o(o({ref:t},d),{},{components:r})):n.createElement(m,o({ref:t},d))}));function p(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},5930:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return h}});var n=r(7462),a=r(3366),i=(r(7294),r(3905)),o=["components"],s={title:"Realtime Search",description:"Doing a realtime search"},l=void 0,c={unversionedId:"guides/realtime-search/doing-a-realtime-search",id:"guides/realtime-search/doing-a-realtime-search",title:"Realtime Search",description:"Doing a realtime search",source:"@site/docs/20-guides/realtime-search/40-doing-a-realtime-search.md",sourceDirName:"20-guides/realtime-search",slug:"/guides/realtime-search/doing-a-realtime-search",permalink:"/docs/guides/realtime-search/doing-a-realtime-search",editUrl:"https://github.com/deepstreamIO/deepstream.io-website/docs/20-guides/realtime-search/40-doing-a-realtime-search.md",tags:[],version:"current",sidebarPosition:40,frontMatter:{title:"Realtime Search",description:"Doing a realtime search"},sidebar:"tutorialSidebar",previous:{title:"Logging in",permalink:"/docs/guides/realtime-search/logging-in"},next:{title:"Permissions",permalink:"/docs/guides/realtime-search/permissions"}},d=[{value:"Making an RPC",id:"making-an-rpc",children:[],level:3},{value:"Request the list",id:"request-the-list",children:[],level:3},{value:"Rendering",id:"rendering",children:[],level:3},{value:"Setting it change",id:"setting-it-change",children:[],level:3}],u={toc:d};function h(e){var t=e.components,r=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"So now we get to the juicier part. Realtime Search works using a combination of the same basic deepstream record or lists APIs, so we don't really need to learn anything new!"),(0,i.kt)("p",null,"The first thing you need to do is make an RPC in order to notify the backend of the query you want to perform. This step isn't entirely necessary as we could just put the query inside of the record or events name, however it provides two important aspects:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"permissions")),(0,i.kt)("p",null,"You can easily permission an RPC using valve as we will see later. This makes it much more secure as we don't need to parse it and can also add meta data into the RPC to strengthen it further"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Size")),(0,i.kt)("p",null,"If you have complex query odds are it's quite long. Normally you want to keep topics as short as possible as they are heavily used, and in some cases long names are not even supported by dbs (like rethinkdb)"),(0,i.kt)("p",null,"If you used the previous realtime-search provider with rethinkdb this will be the only thing you need to change to upgrade"),(0,i.kt)("h3",{id:"making-an-rpc"},"Making an RPC"),(0,i.kt)("p",null,"So the first thing we need to do is make the actual query, in this example we will have one that filters down\neveryone in the user table with an age greater than 30 "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * In order to do the search we call an RPC with the table and query parameters\n * The query parameters are tuples of three:\n * \n * [fieldName, operator, value]\n * \n * Where the operators can be one of:\n * \n * [ eq, ne, match, gt, ge, lt, le, in, contains ]\n * \n * And you can AND them together by just having more:\n * \n * [[fieldName, operator, value], [fieldName, operator, value], [fieldName, operator, value]]\n */\nconst hash = await client.rpc.make('realtime_search', {\n    table: 'user',\n    // age greater than equal to 30\n    query: [['age', 'ge', 30]]\n})\n")),(0,i.kt)("h3",{id:"request-the-list"},"Request the list"),(0,i.kt)("p",null,"The next thing we need to do is request that hash and just to it updating. The simplest way to do this is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const resultList = client.record.getList(`realtime_search/list_${hash}`)\nawait resultList.whenReady()\nresultList.subscribe(results => {\n    console.log(results)\n}, true)\n")),(0,i.kt)("p",null,"However you'll notice the results are actually just record names like ",(0,i.kt)("inlineCode",{parentName:"p"},"user/uuid")," rather than the data itself. This is because we use lists and hence realtime-search returns references to objects, but require the front-end to have to subscribe the individual records. This might sound sound like boiler plate but each application can request data differently depending on their goals. In this guide we'll concentrate on the most common approach of creating a record we can subscribe to it with the correct lifecycle hooks."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const records = new Map()\n\nconst createRecord = async (recordName) => {\n    const record = client.record.getRecord(recordName)\n    records.set(recordName, record)\n}\n\nconst discardRecord = (recordName) => {\n    const record = records.get(recordName)\n    record.discard()\n    records.delete(recordName)\n}\n\nconst resultList = client.record.getList(`realtime_search/list_${hash}`)\nawait resultList.whenReady()\nresultList.forEach(createRecord)\nresultList.on('entry-added', createRecord)\nresultList.on('entry-removed', discardRecord)\n")),(0,i.kt)("h3",{id:"rendering"},"Rendering"),(0,i.kt)("p",null,"Given the simplicity of this app and the lack of framework use I'm going to take the more unconventional route of just rerendering the list whenever it or the data within it changes"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const render = () => {\n    const users = document.createElement('ul')\n    users.className = 'users'\n\n    records.forEach(user => {\n        const template = document.querySelector(\"#user-template\");\n        const clone = document.importNode(template.content, true);\n        const elem = clone.children[0];\n        elem.querySelector('.name span').innerText = user.get('name')\n        elem.querySelector('.age span').innerText = user.get('age')\n        users.append(elem)\n    })\n    \n    document\n        .querySelector(\".users\")\n        .replaceWith(users)\n}\n\nconst createRecord = async (recordName) => {\n    const record = client.record.getRecord(recordName)\n    records.set(recordName, record)\n    await record.whenReady()\n\n    // Render whenever something changes and on initial load\n    record.subscribe(render, true)\n}\n\nconst discardRecord = (recordName) => {\n    const record = records.get(recordName)\n    record.discard()\n    records.delete(recordName)\n\n    // Render whenever it has been discarded\n    render()\n}\n")),(0,i.kt)("h3",{id:"setting-it-change"},"Setting it change"),(0,i.kt)("p",null,"So the best way to make sure this all works is just to do a HTTP post to make sure everything updates properly! The following snippets should be added into files (like upsert-user.sh) as it will make like easier when doing multiple operations. Or just use the ones within the example directory of the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/deepstreamIO/deepstream.io-realtime-search/tree/master/example"},"realtime-search github repo"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When adding/insert a new entry")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"embed:server/realtime-search/example/http/upsert-user.sh")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Deleting a user")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"embed:server/realtime-search/example/http/delete-user.sh")))}h.isMDXComponent=!0}}]);