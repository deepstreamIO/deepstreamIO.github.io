"use strict";(self.webpackChunkdeepstream_io_website=self.webpackChunkdeepstream_io_website||[]).push([[5435],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9755:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"WebRTC 01: Data Channels",description:"Set up a WebRTC connection between two clients and send simple messages",tags:["WebRTC","DataChannels","Text Data","Binary Data"]},l=void 0,c={unversionedId:"guides/webrtc/webrtc-datachannels",id:"guides/webrtc/webrtc-datachannels",title:"WebRTC 01: Data Channels",description:"Set up a WebRTC connection between two clients and send simple messages",source:"@site/docs/20-guides/webrtc/10-webrtc-datachannels.md",sourceDirName:"20-guides/webrtc",slug:"/guides/webrtc/webrtc-datachannels",permalink:"/docs/guides/webrtc/webrtc-datachannels",editUrl:"https://github.com/deepstreamIO/deepstream.io-website/docs/20-guides/webrtc/10-webrtc-datachannels.md",tags:[{label:"WebRTC",permalink:"/docs/tags/web-rtc"},{label:"DataChannels",permalink:"/docs/tags/data-channels"},{label:"Text Data",permalink:"/docs/tags/text-data"},{label:"Binary Data",permalink:"/docs/tags/binary-data"}],version:"current",sidebarPosition:10,frontMatter:{title:"WebRTC 01: Data Channels",description:"Set up a WebRTC connection between two clients and send simple messages",tags:["WebRTC","DataChannels","Text Data","Binary Data"]},sidebar:"tutorialSidebar",previous:{title:"WebRTC: Fundamentals & Concepts",permalink:"/docs/guides/webrtc/webrtc-intro"},next:{title:"WebRTC 02: Many-To-Many connectivity",permalink:"/docs/guides/webrtc/webrtc-full-mesh"}},p=[{value:"Choosing a WebRTC library",id:"choosing-a-webrtc-library",children:[],level:2},{value:"Who&#39;s calling who?",id:"whos-calling-who",children:[],level:2},{value:"Signaling",id:"signaling",children:[],level:2}],u={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Let's start with a simple example: Establishing a connection between two browser windows and sending text messages back and forth. For this we'll use ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en/docs/Web/API/RTCDataChannel"},"WebRTC data-channels")," - the basic connection type that lets you send text and binary data directly between two peers."),(0,o.kt)("h2",{id:"choosing-a-webrtc-library"},"Choosing a WebRTC library"),(0,o.kt)("p",null,"By browser standards the WebRTC API is extremly complicated and low level. When you want to establish a Websocket connection all you need to do is call ",(0,o.kt)("inlineCode",{parentName:"p"},"new Websocket( 'ws://...' )"),"... but with WebRTC the entire connection establishment, generating offers and answers, sending and receiving ICE candidates and other protocol steps are up to you. If you'd like to give it a try I can highly recommend ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Simple_RTCDataChannel_sample"},"Mozilla's DataChannel tutorial"),", but for this guide we'll keep things simpler by using a library."),(0,o.kt)("p",null,"There are many WebRTC libraries available that provide convenience methods or high level abstractions. WebRTC has been an emerging standard and is still somehwhat in flux, so its crucial to make sure that whatever library you choose is up to date and well maintained."),(0,o.kt)("p",null,"For our examples we'll be using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/feross/simple-peer"},"Simple Peer"),": a basic, very clean low level wrapper around P2P connections."),(0,o.kt)("h2",{id:"whos-calling-who"},"Who's calling who?"),(0,o.kt)("p",null,"Time to get our browser windows to call each other. But first we have to work out who's awaiting the call and who's making it. To keep things simple  we'll add a hash ",(0,o.kt)("inlineCode",{parentName:"p"},"#initiator")," to one window's URL. So when establishing the connection we specify"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const p2pConnection = new SimplePeer({\n    initiator: document.location.hash === '#initiator'\n});\n")),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"webrtc-full-mesh"},"full mesh example")," well compare usernames ",(0,o.kt)("inlineCode",{parentName:"p"},"localUserName > remoteUserName")," to achieve the same."),(0,o.kt)("h2",{id:"signaling"},"Signaling"),(0,o.kt)("p",null,"As the connection is being established, both peers need to send information about themselves and how to reach them to each other - the previously mentioned Interactive Connectivity Establishment Process (or ICE for short)."),(0,o.kt)("p",null,"Simple peer makes this easy. Whenever our local peer wants to send a signal to the remote, it emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"'signal'")," event. Whenever we receive a signal we process it using our connection's ",(0,o.kt)("inlineCode",{parentName:"p"},".signal()")," method. The signals themselves are transmitted using ",(0,o.kt)("a",{parentName:"p",href:"../../tutorials/core/pubsub/events"},"events, deepstream's publish/subscribe mechanism"),"."),(0,o.kt)("p",null,"We establish a connection by calling"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const ds = deepstream( '<your dsh url>' ).login();\n")),(0,o.kt)("p",null,"To make sure we're not receiving our own events we'll create a random username on both sides"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const userName = 'user/' + ds.getUid();\n")),(0,o.kt)("p",null,"and use it to filter out our own signals"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"p2pConnection.on( 'signal', signal => {\n    ds.event.emit( 'rtc-signal', {\n        sender: userName,\n        signal: signal\n    });\n});\n\nds.event.subscribe( 'rtc-signal', msg => {\n    if( msg.sender !== userName ) {\n        p2pConnection.signal( msg.signal );\n    }\n});\n")),(0,o.kt)("p",null,"Once established, our connection emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"'connect'")," event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"p2pConnection.on( 'connect', () => {});\n")),(0,o.kt)("p",null,"from here on we can simply send messages using"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"p2pConnection.send( 'Hey ho' );\n")),(0,o.kt)("p",null,"and receive them via"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"p2pConnection.on( 'data', data => {\n    console.log( data.toString() );\n});\n")),(0,o.kt)("p",null,"Bottom line: Establishing a connection between two peers is easy enough - but once we move on to ",(0,o.kt)("a",{parentName:"p",href:"webrtc-full-mesh"},"many-to-many connectivity and rooms"),", things get a little more tricky."))}d.isMDXComponent=!0}}]);