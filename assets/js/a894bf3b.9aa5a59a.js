"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[5060],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=l(n),u=a,h=m["".concat(c,".").concat(u)]||m[u]||p[u]||i;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3526:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={title:"Handling Data Conflicts",description:"This tutorial explains how to handle merge conflicts in deepstream",tags:["merge","deepstream","operational transfers"]},c=void 0,l={unversionedId:"tutorials/core/datasync/handling-data-conflicts",id:"tutorials/core/datasync/handling-data-conflicts",title:"Handling Data Conflicts",description:"This tutorial explains how to handle merge conflicts in deepstream",source:"@site/docs/00-tutorials/20-core/70-datasync/40-handling-data-conflicts.md",sourceDirName:"00-tutorials/20-core/70-datasync",slug:"/tutorials/core/datasync/handling-data-conflicts",permalink:"/docs/tutorials/core/datasync/handling-data-conflicts",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/docs/00-tutorials/20-core/70-datasync/40-handling-data-conflicts.md",tags:[{label:"merge",permalink:"/docs/tags/merge"},{label:"deepstream",permalink:"/docs/tags/deepstream"},{label:"operational transfers",permalink:"/docs/tags/operational-transfers"}],version:"current",sidebarPosition:40,frontMatter:{title:"Handling Data Conflicts",description:"This tutorial explains how to handle merge conflicts in deepstream",tags:["merge","deepstream","operational transfers"]},sidebar:"tutorialSidebar",previous:{title:"Lists",permalink:"/docs/tutorials/core/datasync/lists"},next:{title:"Storing Data",permalink:"/docs/tutorials/core/datasync/storing-data"}},d=[{value:"How does deepstream keep track of data consistency?",id:"how-does-deepstream-keep-track-of-data-consistency",children:[{value:"If the incoming version is the same as the existing version",id:"if-the-incoming-version-is-the-same-as-the-existing-version",children:[],level:4},{value:"If the incoming version is lower than or more than 1 higher than the current version",id:"if-the-incoming-version-is-lower-than-or-more-than-1-higher-than-the-current-version",children:[],level:4}],level:2},{value:"Handling merge conflicts",id:"handling-merge-conflicts",children:[],level:2},{value:"Avoiding merge conflicts",id:"avoiding-merge-conflicts",children:[],level:2}],p={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Merge conflicts can occur when two or more clients write to the same record at the exact same time."),(0,i.kt)("h2",{id:"how-does-deepstream-keep-track-of-data-consistency"},"How does deepstream keep track of data consistency?"),(0,i.kt)("p",null,"deepstream uses incrementing version numbers to make sure changes to records happen in sequence and no intermediary update gets lost. Each message created as a result of a ",(0,i.kt)("inlineCode",{parentName:"p"},"set()")," call contains the version number that the client expects to set the record to."),(0,i.kt)("p",null,"The server will ensure that the version of an incoming update is exactly one higher than the current version. If it is, the update is applied and propagated to all other subscribed clients. If it's not though, one of two things will happen:"),(0,i.kt)("h4",{id:"if-the-incoming-version-is-the-same-as-the-existing-version"},"If the incoming version is the same as the existing version"),(0,i.kt)("p",null,"If the version of an incoming update is the ",(0,i.kt)("strong",{parentName:"p"},"same")," as the current version,\ndeepstream assumes a write conflict. It will keep the current version and send a ",(0,i.kt)("inlineCode",{parentName:"p"},"VERSION_EXISTS")," error to the client that tried to update the record to the existing version. On the client, this will invoke a ",(0,i.kt)("inlineCode",{parentName:"p"},"MERGE_STRATEGY")," function. More about merge strategies below."),(0,i.kt)("h4",{id:"if-the-incoming-version-is-lower-than-or-more-than-1-higher-than-the-current-version"},"If the incoming version is lower than or more than 1 higher than the current version"),(0,i.kt)("p",null,"If versions have gotten out of sync, the server will attempt a reconciliation."),(0,i.kt)("h2",{id:"handling-merge-conflicts"},"Handling merge conflicts"),(0,i.kt)("p",null,"Merge conflicts are handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"MERGE_STRATEGY")," functions. These are exposed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"deepstream")," object and can be set globally when the client is initialized, on a pattern or on a per record basis."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Set merge strategy globally when initialising the client\nclient = deepstream('localhost', { mergeStrategy: deepstream.MERGE_STRATEGIES.LOCAL_WINS })\n\n// Set merge strategy on a pattern when initialising the client\nclient = deepstream('localhost', { mergeStrategy: deepstream.MERGE_STRATEGIES.LOCAL_WINS })\nclient.record.setMergeStrategyRegExp('name', (localValue, localVersion, remoteValue, remoteVersion, callback) => {\n    callback(error, mergedData)\n})\n\n// Set merge strategy on a per record basis\nrec = ds.record.getRecord('some-record')\nrec.setMergeStrategy(deepstream.MERGE_STRATEGIES.REMOTE_WINS)\n")),(0,i.kt)("p",null,"By default, ",(0,i.kt)("inlineCode",{parentName:"p"},"LOCAL_WINS")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"REMOTE_WINS")," are available. It is also possible to implement custom merge strategies, e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Accept remote title, but keep local content\nrec.setMergeStrategy(( record, remoteData, remoteVersion, callback ) => {\n    callback( null, {\n        title: remoteData.title,\n        content: record.get( 'content' )\n    });\n});\n")),(0,i.kt)("h2",{id:"avoiding-merge-conflicts"},"Avoiding merge conflicts"),(0,i.kt)("p",null,"The more granular you structure your records, the rarer merge conflicts will be. Generally, deepstream is better at coping with a large number of small records than with a few very large ones.\nEspecially when it comes to records with high upstream and downstream rates, e.g. am item on an auction site with quickly updating prices, it might make sense to make the upstream (e.g. the bids a client submits) a separate record or model them as events or RPCs"))}m.isMDXComponent=!0}}]);