"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[6002],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(n),h=a,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4645:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={title:"Records",description:"Learn how you can use records and access the powerful benefits of datasync",icon:"IoMdAddCircleOutline"},c=void 0,l={unversionedId:"tutorials/core/datasync/records",id:"tutorials/core/datasync/records",title:"Records",description:"Learn how you can use records and access the powerful benefits of datasync",source:"@site/docs/00-tutorials/20-core/70-datasync/10-records.md",sourceDirName:"00-tutorials/20-core/70-datasync",slug:"/tutorials/core/datasync/records",permalink:"/docs/tutorials/core/datasync/records",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/docs/00-tutorials/20-core/70-datasync/10-records.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Records",description:"Learn how you can use records and access the powerful benefits of datasync",icon:"IoMdAddCircleOutline"},sidebar:"tutorialSidebar",previous:{title:"Query connected clients",permalink:"/docs/tutorials/core/presence/query-clients"},next:{title:"Anonymous Records",permalink:"/docs/tutorials/core/datasync/anonymous-records"}},d=[{value:"Using records",id:"using-records",children:[],level:2},{value:"Paths",id:"paths",children:[],level:2},{value:"Record lifecycle",id:"record-lifecycle",children:[{value:"Discarding Records",id:"discarding-records",children:[],level:4},{value:"Deleting Records",id:"deleting-records",children:[],level:4},{value:"Unsubscribe, Discard and Delete - what&#39;s the difference?",id:"unsubscribe-discard-and-delete---whats-the-difference",children:[],level:4}],level:2},{value:"Getting a snapshot",id:"getting-a-snapshot",children:[],level:2},{value:"Naming records",id:"naming-records",children:[{value:"Can&#39;t unique id&#39;s clash?",id:"cant-unique-ids-clash",children:[],level:4},{value:"Can I use more descriptive record names?",id:"can-i-use-more-descriptive-record-names",children:[],level:4},{value:"Making the username part of the record name",id:"making-the-username-part-of-the-record-name",children:[],level:4}],level:2},{value:"Listening",id:"listening",children:[],level:2}],p={toc:d};function u(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Records are the main building blocks of deepstream's data-sync capabilities. They are atomic bits of JSON data that can be manipulated and observed. Any change to a record is instantly synced across all connected clients."),(0,i.kt)("h2",{id:"using-records"},"Using records"),(0,i.kt)("p",null,"Records are requested using ",(0,i.kt)("inlineCode",{parentName:"p"},"client.record.getRecord(name)"),". If a record with the specified name doesn't exist yet, it will be created on the fly. If you just want to check if a record exists without creating it, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"client.record.has(name, callback)"),"."),(0,i.kt)("p",null,"Records have ",(0,i.kt)("inlineCode",{parentName:"p"},"set()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," methods to interact with their data and ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe()")," to inform you about updates. Here's what that would look like in action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Client A: Hungry customer sees pizza delivery approach on map\nconst driver = client.record.getRecord('driver/jack')\ndriver.subscribe('coords', updateMapPointer)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Client B: Delivery driver's smartphone feeds position into record\nconst driver = client.record.getRecord('driver/jack')\nnavigator.geolocation.watchPosition(position => {\n  driver.set('coords', position.coords)\n})\n")),(0,i.kt)("h2",{id:"paths"},"Paths"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"get()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"set()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribe()")," can be used to get the entire record's data, but also support \"paths\". Paths let you access sub-parts of your record's data using JSON notation, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"pets[1].fur.color"),". If a value for a path that doesn't exist yet is set, the path will be created on the fly."),(0,i.kt)("h2",{id:"record-lifecycle"},"Record lifecycle"),(0,i.kt)("p",null,"When calling ",(0,i.kt)("inlineCode",{parentName:"p"},"client.record.getRecord(name)"),", one of three things can happen:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the record doesn't exist on the client or the server yet, it will be created. The initial data of a newly created record is an empty object ",(0,i.kt)("inlineCode",{parentName:"p"},"{}"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the record exists on the server, but hasn't been loaded on the client yet, it will be retrieved.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the record is already loaded on the client, its instance will be returned."))),(0,i.kt)("p",null,"Independent of whether the record has been loaded yet, ",(0,i.kt)("inlineCode",{parentName:"p"},"getRecord(name)")," will return a record instance straight away. You can already start setting values or subscribing to updates at this point, however ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," calls might return ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,i.kt)("p",null,"To ensure a record is fully loaded, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"whenReady()")," method."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Please note:\nThis method will execute synchronously when the record is already available or asynchronously if its still being loaded.\nIf the record is not yet available and still being loaded, it will slow down the operation, for low latency and high write frequency its more performant not to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"whenReady()")," method."),(0,i.kt)("pre",{parentName:"div"},(0,i.kt)("code",{parentName:"pre",className:"language-js"},"for (let index = 0; index < 1000; index++) {\n  \x3c!-- faster --\x3e\n  const record = client.record.getRecord(`${index}`)\n  record.set('index', index)\n  \x3c!-- slower if record not already on client --\x3e\n  const record = await client.record.getRecord(`${index}`).whenReady()\n  record.set('index', index)\n}\n")))),(0,i.kt)("h4",{id:"discarding-records"},"Discarding Records"),(0,i.kt)("p",null,"To inform the server that you're no longer interested in updates for a record, call ",(0,i.kt)("inlineCode",{parentName:"p"},"discard()"),"."),(0,i.kt)("h4",{id:"deleting-records"},"Deleting Records"),(0,i.kt)("p",null,"Records can be deleted using ",(0,i.kt)("inlineCode",{parentName:"p"},"delete()"),". Deleting also discards the record. Whenever a record is deleted by one client, the same record on all other clients will emit a ",(0,i.kt)("inlineCode",{parentName:"p"},"delete")," event."),(0,i.kt)("h4",{id:"unsubscribe-discard-and-delete---whats-the-difference"},"Unsubscribe, Discard and Delete - what's the difference?"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"unsubscribe()")," removes an existing subscription to updates to a record or path. This is purely a client side operation and doesn't notify the server."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"discard()")," tells the server that you're no longer interested in receiving updates for the record."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"delete()")," irreversibly deletes the record from the database and cache and notifies all servers and clients within the cluster of the deletion."),(0,i.kt)("h2",{id:"getting-a-snapshot"},"Getting a snapshot"),(0,i.kt)("p",null,"If you just require a static one-off view into a record's data, but not bother with the entire lifecycle you can also use ",(0,i.kt)("inlineCode",{parentName:"p"},"client.record.snapshot(name, callback)")),(0,i.kt)("h2",{id:"naming-records"},"Naming records"),(0,i.kt)("p",null,"Each record is identified by a name that needs to be unique across the entire system. So what does a great recordname look like? Something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const book = client.record.getRecord('book/iq6auu7d-p9i1vz3q0yi')\n")),(0,i.kt)("p",null,"This name consists of different parts: ",(0,i.kt)("inlineCode",{parentName:"p"},"book")," is the category of the record. ",(0,i.kt)("inlineCode",{parentName:"p"},"/")," is used as a split-character by many database connectors to sort records into tables. ",(0,i.kt)("inlineCode",{parentName:"p"},"iq6auu7d-p9i1vz3q0yi")," is a unique id. Unique ids can be generated on the client using ",(0,i.kt)("inlineCode",{parentName:"p"},"client.getUid()"),". They consist of a base64 encoded millisecond timestamp and a random string. UIDs are a common concept in distributed systems as they eliminate the need for a centralized, incremental id."),(0,i.kt)("h4",{id:"cant-unique-ids-clash"},"Can't unique id's clash?"),(0,i.kt)("p",null,"Theoretically: yes. But the chances for two ids that were generated within the exact same millisecond to be the same are 1:1x10^16 - or one to 10 quadrillion - which is considered an acceptable risk."),(0,i.kt)("h4",{id:"can-i-use-more-descriptive-record-names"},"Can I use more descriptive record names?"),(0,i.kt)("p",null,"Absolutely, any string can be used as a record name. But you need to be certain that the string never changes. This is the case for many institutional usecases that are already based on unique ids. If you're building a stock trading platform, it's perfectly fine to name your record for Microsoft's stock ",(0,i.kt)("inlineCode",{parentName:"p"},"stock/msft"),"."),(0,i.kt)("h4",{id:"making-the-username-part-of-the-record-name"},"Making the username part of the record name"),(0,i.kt)("p",null,"Many permissioning strategies in deepstream are based on record, event or\nrpc-names and the data they contain.  To make sure that only ",(0,i.kt)("inlineCode",{parentName:"p"},"johndoe")," can\nchange his settings, you would call your record ",(0,i.kt)("inlineCode",{parentName:"p"},"settings/johndoe")," and specify\nan associated ",(0,i.kt)("a",{parentName:"p",href:"../permission/valve-simple/"},"Valve rule"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'record:\n  settings/$username:\n    write: "$username === user.id"\n')),(0,i.kt)("h2",{id:"listening"},"Listening"),(0,i.kt)("p",null,'Records also support a concept called "listening". Every client can register as a listener for record name patterns, e.g. ',(0,i.kt)("inlineCode",{parentName:"p"},"^settings/.*"),". Whenever other clients start subscribing to records that match said pattern, the listener will be notified."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Client B\nclient.record.listen('settings/.*', (match, response) => {\n  console.log(match) // 'settings/security'\n  if (/* if you want to provide */) {\n    // start publishing to this record via `client.record.setData(match, data, ack)`\n    response.accept()\n\n    response.onStop(() => {\n      // stop publishing to this record when no one is interested\n    })\n  } else {\n    response.reject() // let deepstream ask another provider\n  }\n})\n")),(0,i.kt)("p",null,'This is useful to create "active" data providers - backend processes that only send out data that\'s actually requested. A few things worth mentioning about listening:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The listen-callback is called once the first client subscribes to a matching record and ",(0,i.kt)("inlineCode",{parentName:"p"},"onStop")," is called once the last subscriber for a matching record unsubscribes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Listening also keeps state. Registering as a listener for a pattern that already has matching subscriptions will call the callback multiple times straight away, once for every matching subscription that doesn't have a provider.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Records have a ",(0,i.kt)("inlineCode",{parentName:"p"},"hasProvider")," property that allows you to see if a service has accepted the listen request. This allows you to guarantee the data isn't stale."))))}u.isMDXComponent=!0}}]);