"use strict";(self.webpackChunkdeepstream_io_website=self.webpackChunkdeepstream_io_website||[]).push([[7337],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return c}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(a),c=r,h=u["".concat(s,".").concat(c)]||u[c]||m[c]||l;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},2248:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return u}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],o={title:"Modelling relational data",tags:["relational","relational data","deepstream","records","sql"]},s=void 0,d={unversionedId:"tutorials/concepts/modelling-relational-data",id:"tutorials/concepts/modelling-relational-data",title:"Modelling relational data",description:"Relational data with deepstream",source:"@site/docs/00-tutorials/00-concepts/40-modelling-relational-data.md",sourceDirName:"00-tutorials/00-concepts",slug:"/tutorials/concepts/modelling-relational-data",permalink:"/docs/tutorials/concepts/modelling-relational-data",editUrl:"https://github.com/deepstreamIO/deepstream.io-website/docs/00-tutorials/00-concepts/40-modelling-relational-data.md",tags:[{label:"relational",permalink:"/docs/tags/relational"},{label:"relational data",permalink:"/docs/tags/relational-data"},{label:"deepstream",permalink:"/docs/tags/deepstream"},{label:"records",permalink:"/docs/tags/records"},{label:"sql",permalink:"/docs/tags/sql"}],version:"current",sidebarPosition:40,frontMatter:{title:"Modelling relational data",tags:["relational","relational data","deepstream","records","sql"]},sidebar:"tutorialSidebar",previous:{title:"Security Overview",permalink:"/docs/tutorials/concepts/security"},next:{title:"Active Data Providers",permalink:"/docs/tutorials/concepts/active-data-providers"}},p=[{value:"Relational data with deepstream",id:"relational-data-with-deepstream",children:[{value:"1 - 1 relation",id:"1---1-relation",children:[{value:"users/abc-123",id:"usersabc-123",children:[],level:6},{value:"details/abc-123",id:"detailsabc-123",children:[],level:5}],level:3},{value:"1 - n relation",id:"1---n-relation",children:[{value:"users/abc-123",id:"usersabc-123-1",children:[],level:6},{value:"addresses/789",id:"addresses789",children:[],level:6}],level:3},{value:"m - n relation",id:"m---n-relation",children:[{value:"A list pointer in each <code>Record</code>",id:"a-list-pointer-in-each-record",children:[{value:"groups/1234",id:"groups1234",children:[],level:6},{value:"users/123",id:"users123",children:[],level:6}],level:5},{value:"An intermediary relationship <code>Record</code>",id:"an-intermediary-relationship-record",children:[{value:"memberships/q6756i9",id:"membershipsq6756i9",children:[],level:6},{value:"users/123",id:"users123-1",children:[],level:6},{value:"groups/1234",id:"groups1234-1",children:[],level:6}],level:5},{value:"Adding a user to our hiking group",id:"adding-a-user-to-our-hiking-group",children:[],level:5},{value:"Getting all members of our hiking group and when they joined",id:"getting-all-members-of-our-hiking-group-and-when-they-joined",children:[],level:5}],level:3}],level:2}],m={toc:p};function u(e){var t=e.components,a=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"relational-data-with-deepstream"},"Relational data with deepstream"),(0,l.kt)("p",null,"Relational databases are common in our industry, and quite often developers learn to model their data using relational techniques. Learning how to represent these common patterns in NoSQL solutions is hugely beneficial for both green field projects and enhancements for legacy software."),(0,l.kt)("p",null,"We're going to take a dive into representing some common relationships using deepstream's ",(0,l.kt)("inlineCode",{parentName:"p"},"Records"),". These are tiny blobs of JSON that we can subscribe to, update and permission. They are persisted to both a cache and database, making writes quick, reads quicker and updates ",(0,l.kt)("inlineCode",{parentName:"p"},"realtime"),"."),(0,l.kt)("h3",{id:"1---1-relation"},"1 - 1 relation"),(0,l.kt)("p",null,"A way to model 1 - 1 data is often not needed in applications and traditional SQL databases. In most cases data can be merged into a single table or document/collection."),(0,l.kt)("p",null,"However sometimes we end up with a ",(0,l.kt)("inlineCode",{parentName:"p"},"customer")," table like this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"id"),(0,l.kt)("th",{parentName:"tr",align:null},"firstname"),(0,l.kt)("th",{parentName:"tr",align:null},"lastname"),(0,l.kt)("th",{parentName:"tr",align:null},"info"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"alex"),(0,l.kt)("td",{parentName:"tr",align:null},"harley"),(0,l.kt)("td",{parentName:"tr",align:null},"Like's pizza")))),(0,l.kt)("p",null,"And a ",(0,l.kt)("inlineCode",{parentName:"p"},"customer_details")," table like this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"user_id"),(0,l.kt)("th",{parentName:"tr",align:null},"address"),(0,l.kt)("th",{parentName:"tr",align:null},"card_number"),(0,l.kt)("th",{parentName:"tr",align:null},"dob"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"Berlin"),(0,l.kt)("td",{parentName:"tr",align:null},"xxx-xxx-xxx-xxx"),(0,l.kt)("td",{parentName:"tr",align:null},"1901")))),(0,l.kt)("p",null,"In these situations, it would never make sense for a ",(0,l.kt)("inlineCode",{parentName:"p"},"customer")," to have multiple sets of ",(0,l.kt)("inlineCode",{parentName:"p"},"customer_details"),", and it would never make sense for a ",(0,l.kt)("inlineCode",{parentName:"p"},"customer_details")," row to belong to more than one ",(0,l.kt)("inlineCode",{parentName:"p"},"customer"),". Here the relationship is strictly 1 - 1."),(0,l.kt)("p",null,"In terms of usage with deepstream, this could be useful if we don't always want to load a large amount of data for a user each time we fetch them. Or it may make sense to have a separate ",(0,l.kt)("inlineCode",{parentName:"p"},"Record")," for a user's billing data that we don't need to fetch each time."),(0,l.kt)("p",null,"The way to model this data is to use a pointer to another ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),", inside the original ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),". It might look a bit like this:"),(0,l.kt)("h6",{id:"usersabc-123"},"users/abc-123"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"{\n    firstname: 'Alex',\n    lastname: 'Smith',\n    detailsRecord: 'details/abc-123'\n}\n")),(0,l.kt)("h5",{id:"detailsabc-123"},"details/abc-123"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"{\n    address: 'Berlin',\n    cardNumber: 'xxx-xxx-xxx-xxx',\n    dob: 1901\n}\n")),(0,l.kt)("p",null,"Now we can get a bit of info about a user at any time:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const record = client.record.getRecord('users/abc-123')\nrecord.whenReady((record) => {\n    const { firstname, lastname, detailsRecord } = record.get()\n})\n")),(0,l.kt)("p",null,"And whenever the user themselves wants to look at their details or update them, it's as simple as:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const detailsRec = client.record.getRecord(detailsRecord)\ndetailsRec.whenReady((record) => {\n    const { address, cardNumber, dob } = record.get()\n})\n")),(0,l.kt)("p",null,"Another benefit of this is that it makes it super easy to permission different parts of the data set. Let's pretend that whenever we mouse-over a user we want to display their name and a bit of info about them. This way, we only need to fetch the ",(0,l.kt)("inlineCode",{parentName:"p"},"users/abc-123")," ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),"."),(0,l.kt)("p",null,"However the only person that should be able to look at a users card details is themselves. So we can permission the details ",(0,l.kt)("inlineCode",{parentName:"p"},"Records")," in a way to enforce this using ",(0,l.kt)("a",{parentName:"p",href:"../../tutorials/core/permission/valve-simple"},"Valve"),". The rule to do this might look a bit as follows, all we're doing is enforcing that the only user who can read and write to a ",(0,l.kt)("inlineCode",{parentName:"p"},"details/")," record is the user themself."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'record:\n  "details/$userId":\n    read: "user.id === userId"\n    write: "user.id === userId"\n')),(0,l.kt)("h3",{id:"1---n-relation"},"1 - n relation"),(0,l.kt)("p",null,"Let's stay on track and look into a more involved example with some 1 - n relationships."),(0,l.kt)("p",null,"In long lived applications, it is quite common to find that users update their addresses for whatever reason. Usually this is fine, however in certain situations (often when payments are involved), we need to keep a history of those addresses. In this case, we have a 1 - n relationship where customers have multiple addresses."),(0,l.kt)("p",null,"With the relational model, we can end up with a ",(0,l.kt)("inlineCode",{parentName:"p"},"customer")," table:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"id"),(0,l.kt)("th",{parentName:"tr",align:null},"firstname"),(0,l.kt)("th",{parentName:"tr",align:null},"lastname"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"alex"),(0,l.kt)("td",{parentName:"tr",align:null},"harley")))),(0,l.kt)("p",null,"And an ",(0,l.kt)("inlineCode",{parentName:"p"},"address")," table like this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"user_id"),(0,l.kt)("th",{parentName:"tr",align:null},"street_address"),(0,l.kt)("th",{parentName:"tr",align:null},"city"),(0,l.kt)("th",{parentName:"tr",align:null},"post_code"),(0,l.kt)("th",{parentName:"tr",align:null},"country"),(0,l.kt)("th",{parentName:"tr",align:null}))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"123 Marienstrasse"),(0,l.kt)("td",{parentName:"tr",align:null},"Berlin"),(0,l.kt)("td",{parentName:"tr",align:null},"88763"),(0,l.kt)("td",{parentName:"tr",align:null},"Germany"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("p",null,"Where the ",(0,l.kt)("inlineCode",{parentName:"p"},"user_id")," column has a foreign key constraint on the ",(0,l.kt)("inlineCode",{parentName:"p"},"id")," column of the ",(0,l.kt)("inlineCode",{parentName:"p"},"customer")," table."),(0,l.kt)("p",null,"Modelling this with deepstream is simple, instead of a pointer a ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),", this time we just point towards a ",(0,l.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,l.kt)("h6",{id:"usersabc-123-1"},"users/abc-123"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"{\n    firstname: 'Alex',\n    lastname: 'Smith',\n    addresses: 'abc-123-addresses' // [ 'addresses/789', 'addresses/894 ]\n}\n")),(0,l.kt)("p",null,"This list ",(0,l.kt)("inlineCode",{parentName:"p"},"abc-123-addresses")," itself just contains pointers to the actual address ",(0,l.kt)("inlineCode",{parentName:"p"},"Records"),". One of these may look as follows:"),(0,l.kt)("h6",{id:"addresses789"},"addresses/789"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"{\n    streetAddress: '123 Marienstrasse',\n    city: 'Berlin',\n    postCode: '88763',\n    country: 'Germany'\n}\n")),(0,l.kt)("p",null,"When it comes to fetching these addresses (assuming we already have the user ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),"), we can do this as follows and render them:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"\n// From user Record with id 'users/abc-123', asyncronously request the List id referenced in user property 'addresses'.  E.g. List id 'abc-123-addresses'\nconst addressList = client.record.getList('addresses')\n\n// When List 'abc-123-addresses' is ready, iterate it's references to address Record ids.  E.g. Record id 'addresses/789'\naddressList.whenReady((list) => {\n    list.forEach(printAddress)\n})\n\n// Function passed to forEach() to print one particular address Record.  E.g. 'addresses/789'\nconst printAddress = (recordName) => {\n    const record = client.record.getRecord(recordName)\n    record.whenReady(record => console.log(record.get()))\n}\n\n// { streetAddress: '123 Marienstrasse', city: 'Berlin', postCode: '88763', country: 'Germany' }\n// { streetAddress: '64 Engeldamm', city: 'Berlin', postCode: '12345', country: 'Germany' }\n")),(0,l.kt)("h3",{id:"m---n-relation"},"m - n relation"),(0,l.kt)("p",null,"Let's again take a more involved look into these relations and look at many - many relationships. There are a few different ways of doing this with ",(0,l.kt)("inlineCode",{parentName:"p"},"Records"),", each with their own trade offs. Some are better suited for querying, some less so, but it all depends on the use case at hand."),(0,l.kt)("p",null,"Consider the social network situation where you have Groups and People, groups may contain many people and each person may belong to many groups. Using the relational model, it might look a bit like the following:"),(0,l.kt)("p",null,"We have a ",(0,l.kt)("inlineCode",{parentName:"p"},"user")," table:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"id"),(0,l.kt)("th",{parentName:"tr",align:null},"firstname"),(0,l.kt)("th",{parentName:"tr",align:null},"lastname"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"alex"),(0,l.kt)("td",{parentName:"tr",align:null},"harley")))),(0,l.kt)("p",null,"And a ",(0,l.kt)("inlineCode",{parentName:"p"},"group")," table like this:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"id"),(0,l.kt)("th",{parentName:"tr",align:null},"name"),(0,l.kt)("th",{parentName:"tr",align:null},"about"),(0,l.kt)("th",{parentName:"tr",align:null},"city"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"78"),(0,l.kt)("td",{parentName:"tr",align:null},"hiking"),(0,l.kt)("td",{parentName:"tr",align:null},"A place for hikers"),(0,l.kt)("td",{parentName:"tr",align:null},"Berlin")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"96"),(0,l.kt)("td",{parentName:"tr",align:null},"gaming"),(0,l.kt)("td",{parentName:"tr",align:null},"Gaming all day"),(0,l.kt)("td",{parentName:"tr",align:null},"Auckland")))),(0,l.kt)("p",null,"Then a join table ",(0,l.kt)("inlineCode",{parentName:"p"},"groups_users")," as follows:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"user_id"),(0,l.kt)("th",{parentName:"tr",align:null},"group_id"),(0,l.kt)("th",{parentName:"tr",align:null},"membership_type"),(0,l.kt)("th",{parentName:"tr",align:null}))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"78"),(0,l.kt)("td",{parentName:"tr",align:null},"admin"),(0,l.kt)("td",{parentName:"tr",align:null})),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"23"),(0,l.kt)("td",{parentName:"tr",align:null},"96"),(0,l.kt)("td",{parentName:"tr",align:null},"member"),(0,l.kt)("td",{parentName:"tr",align:null})))),(0,l.kt)("p",null,"Now let's have a look at doing this with ",(0,l.kt)("inlineCode",{parentName:"p"},"Records"),"."),(0,l.kt)("h5",{id:"a-list-pointer-in-each-record"},"A list pointer in each ",(0,l.kt)("inlineCode",{parentName:"h5"},"Record")),(0,l.kt)("p",null,"Perhaps the most basic way of expressing a many - many relationship, we can simply reference a ",(0,l.kt)("inlineCode",{parentName:"p"},"List")," in each ",(0,l.kt)("inlineCode",{parentName:"p"},"Record")," in the dataset, that points to more data."),(0,l.kt)("p",null,"Here we have group ",(0,l.kt)("inlineCode",{parentName:"p"},"1234"),", which has members interested in hiking and was created at ",(0,l.kt)("inlineCode",{parentName:"p"},"12345435"),"."),(0,l.kt)("h6",{id:"groups1234"},"groups/1234"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n    name: "hiking",\n    created: 12345435,\n    memberList: "members-1234" // [ "users/123", "users/124" ]\n}\n')),(0,l.kt)("p",null,"One of these users looks like this, and also contains a list of the groups they're a part of:"),(0,l.kt)("h6",{id:"users123"},"users/123"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n    firstname: "Alex",\n    lastname: "Smith",\n    groupList: "groups-xyz" // [ "groups/1234" ]\n}\n')),(0,l.kt)("p",null,"This way of modelling data is very easy to reason about and makes it simple to query from both sides i.e. all the groups a user belongs to, and all the users in a group."),(0,l.kt)("p",null,"A downside however is that adding or removing a user from a group can be more complicated. We have to do two writes/deletes, once on the users side and once on the groups side."),(0,l.kt)("h5",{id:"an-intermediary-relationship-record"},"An intermediary relationship ",(0,l.kt)("inlineCode",{parentName:"h5"},"Record")),(0,l.kt)("p",null,"The above example is great for just expressing a relationship between records, but if we want to have any extra data associated with these we'll need an intermediary ",(0,l.kt)("inlineCode",{parentName:"p"},"Record")," to store additional metadata about the relationship. In this case, we may want to have a users type of membership in a group."),(0,l.kt)("p",null,"Let's have a look at how one of these ",(0,l.kt)("inlineCode",{parentName:"p"},"Records")," would be structured:"),(0,l.kt)("h6",{id:"membershipsq6756i9"},"memberships/q6756i9"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n    type: "admin",\n    joined: 12787434,\n    referrals: 8\n}\n')),(0,l.kt)("p",null,"From here, both groups and user ",(0,l.kt)("inlineCode",{parentName:"p"},"Records")," will point to lists that contain these."),(0,l.kt)("h6",{id:"users123-1"},"users/123"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n    firstname: "Alex",\n    lastname: "Smith",\n    memberships: "memberships-123" // [ memberships/q6756i9 ]\n}\n')),(0,l.kt)("h6",{id:"groups1234-1"},"groups/1234"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n    name: "hiking",\n    created: 12345435,\n    memberships: "memberships-1234" // [ memberships/q6756i9 ]\n}\n')),(0,l.kt)("p",null,"The basic idea around fetching data from this type of setup, is that we need to load, a couple of different ",(0,l.kt)("inlineCode",{parentName:"p"},"Lists")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Records")," to get everything we need. Let's quickly cover some example queries we can do with this:"),(0,l.kt)("h5",{id:"adding-a-user-to-our-hiking-group"},"Adding a user to our hiking group"),(0,l.kt)("p",null,"The first thing we need to do is get references to our group and user ",(0,l.kt)("inlineCode",{parentName:"p"},"Records"),". From here we need to create our new membership record. Under the hood, the ",(0,l.kt)("inlineCode",{parentName:"p"},"getRecord")," function actually does a ",(0,l.kt)("inlineCode",{parentName:"p"},"CREATE OR READ")," call, so the syntax for getting and creating ",(0,l.kt)("inlineCode",{parentName:"p"},"Records")," is the same."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const groupRecord = client.record.getRecord('groups/1234')\nconst userRecord = client.record.getRecord('users/123')\nconst mId = `memberships/${client.getUid()}`\nconst membershipRecord = client.record.getRecord(mId)\n")),(0,l.kt)("p",null,"Next we need to set the data of our membership ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),", for now we only have the ",(0,l.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"joined")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"referrals")," properties."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"membershipRecord.set({\n    userId: 'users/123',\n    groupId: 'groups/1234',\n    type: \"user\", // could be admin, organiser, etc\n    joined: Date.now(),\n    referrals: 0\n})\n")),(0,l.kt)("p",null,"Lastly we just need to add this membership ",(0,l.kt)("inlineCode",{parentName:"p"},"Record")," to the user and group membership ",(0,l.kt)("inlineCode",{parentName:"p"},"Lists"),". For brevity I'll just show adding the membership to the group, however the code is exactly the same for adding to the user membership list."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const membershipListName = groupRecord.get('memberships')\nconst groupList = client.record.getList(membershipListName)\ngroupList.addEntry(mId)\n")),(0,l.kt)("p",null,"And now we have a relationship between two entities in our application. The code for removing a user from a group, would also be very similar."),(0,l.kt)("h5",{id:"getting-all-members-of-our-hiking-group-and-when-they-joined"},"Getting all members of our hiking group and when they joined"),(0,l.kt)("p",null,"Let's say we wanted to list all members of our hiking group. This is pretty simple and can be accomplished very quickly. First we just need to get a reference to our group ",(0,l.kt)("inlineCode",{parentName:"p"},"Record"),", and then call our ",(0,l.kt)("inlineCode",{parentName:"p"},"enumerateMembers")," function with our membership list."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"const record = client.record.getRecord('groups/1234')\nrecord.whenReady((record) => {\n    enumerateMembers(record.get('memberships'))\n})\n")),(0,l.kt)("p",null,"Our ",(0,l.kt)("inlineCode",{parentName:"p"},"enumerateMembers")," function simply gets the ",(0,l.kt)("inlineCode",{parentName:"p"},"Record")," for each of our memberships. It calls both the ",(0,l.kt)("inlineCode",{parentName:"p"},"displayUser")," function with the users Id and when they joined."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"function enumerateMembers(memberList) {\n    memberList.forEach((membershipId) => {\n        const memberRecord = client.record.getRecord(membership)\n        memberRecord.whenReady(record => {\n            displayUser(record.get('userId'), record.get('joined'))\n        })\n    }\n}\n")),(0,l.kt)("p",null,"Finally our ",(0,l.kt)("inlineCode",{parentName:"p"},"displayUser")," function just loads the users ",(0,l.kt)("inlineCode",{parentName:"p"},"Record")," and logs their name and when they joined the hiking group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"function displayUser(userId, joined) {\n    const userRecord = client.record.getRecord(userId)\n    userRecord.whenReady((record) => {\n        console.log(`${record.get('firstname')} has been in the hiking group since ${formatDate(joined)}`)\n    })\n}\n")),(0,l.kt)("p",null,"And just like that, it's pretty easy to query all kinds of different things with this set up. Finding all of a user's groups would be a similar exercise to what we've just done, however I'll leave that up to you."))}u.isMDXComponent=!0}}]);