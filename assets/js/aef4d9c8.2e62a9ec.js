"use strict";(self.webpackChunkdeepstreamio_github_io=self.webpackChunkdeepstreamio_github_io||[]).push([[7211],{3059:(e,n,t)=>{t.d(n,{A:()=>r});const r="data:image/jpeg;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6NzI3MmRjMDIwNjM1Zjg1NTNiNzVkZGYzYTY0YjRlYzYxNThiNjQ0NjNjODA1Nzk5NDRiNTVmNWQ1NTBlYzhmYQpzaXplIDEyNTEwMzYK"},5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>h});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),d=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=d(e.components);return r.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(t),g=a,h=c["".concat(s,".").concat(g)]||c[g]||u[g]||o;return t?r.createElement(h,i(i({ref:n},p),{},{components:t})):r.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=g;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var d=2;d<o;d++)i[d]=t[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}g.displayName="MDXCreateElement"},7561:(e,n,t)=>{t.d(n,{A:()=>r});const r="data:image/png;base64,dmVyc2lvbiBodHRwczovL2dpdC1sZnMuZ2l0aHViLmNvbS9zcGVjL3YxCm9pZCBzaGEyNTY6NjFhZDFjMTljY2ZkNTBmNWRmYTA1ZGFjN2U4OTMwMDkxNDM3MTcxMmNkYzNkMzZmMGJjNWUyZDE2NDAxOTAwZgpzaXplIDM3MDI4Cg=="},9733:(e,n,t)=>{t.r(n),t.d(n,{contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=t(8168),a=(t(6540),t(5680));const o={title:"IoT Fridge Monitor",description:"deepstream HTTP Internet of Things Fridge Monitor tutorial",tags:["HTTP","IoT","Arduino","ESP8266","WiFi"]},i=void 0,l={unversionedId:"guides/example-apps/http-iot-fridge-monitor",id:"guides/example-apps/http-iot-fridge-monitor",title:"IoT Fridge Monitor",description:"deepstream HTTP Internet of Things Fridge Monitor tutorial",source:"@site/docs/20-guides/example-apps/http-iot-fridge-monitor.md",sourceDirName:"20-guides/example-apps",slug:"/guides/example-apps/http-iot-fridge-monitor",permalink:"/docs/guides/example-apps/http-iot-fridge-monitor",editUrl:"https://github.com/deepstreamIO/deepstreamIO.github.io/docs/20-guides/example-apps/http-iot-fridge-monitor.md",tags:[{label:"HTTP",permalink:"/docs/tags/http"},{label:"IoT",permalink:"/docs/tags/io-t"},{label:"Arduino",permalink:"/docs/tags/arduino"},{label:"ESP8266",permalink:"/docs/tags/esp-8266"},{label:"WiFi",permalink:"/docs/tags/wi-fi"}],version:"current",frontMatter:{title:"IoT Fridge Monitor",description:"deepstream HTTP Internet of Things Fridge Monitor tutorial",tags:["HTTP","IoT","Arduino","ESP8266","WiFi"]},sidebar:"tutorialSidebar",previous:{title:"Guides",permalink:"/docs/guides/"},next:{title:"IoT Light Sensor",permalink:"/docs/guides/example-apps/http-iot"}},s=[{value:"Hardware",id:"hardware",children:[],level:2},{value:"Setting up",id:"setting-up",children:[],level:2},{value:"Reading the button state",id:"reading-the-button-state",children:[],level:2},{value:"Connecting to WiFi",id:"connecting-to-wifi",children:[],level:2},{value:"Building a request",id:"building-a-request",children:[],level:2},{value:"Handling failure",id:"handling-failure",children:[],level:2}],d={toc:s},p="wrapper";function c(e){let{components:n,...o}=e;return(0,a.yg)(p,(0,r.A)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"deepstream's HTTP API is perfect for low-frequency data updates in low-power environments where the cost of establishing and maintaining a WebSocket connection can be prohibitive."),(0,a.yg)("p",null,"In this tutorial we'll use a remote, low-power ESP8266-based system-on-chip and a light sensor to send live light readings to deepstream and display them on a webpage. Additionally, red and green LEDs will show whether the update has been successful."),(0,a.yg)("p",null,"I'd recommend being familiar with the basics of ",(0,a.yg)("a",{parentName:"p",href:"../../tutorials/core/datasync/records"},"Records")," before you start."),(0,a.yg)("p",null,"Here's how it looks:"),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"circuit",src:t(3059).A})),(0,a.yg)("h2",{id:"hardware"},"Hardware"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},'Get hold of a board with an ESP8266 chip. There are many such boards\navailable through merchants and action sites for as little as $5. The one\nwe\'re using is listed as an "Elegiant Nodemcu Lua ESP8266 ESP 12E" and cost\n\u20ac10 delivered.'),(0,a.yg)("li",{parentName:"ul"},"An electronics breadboard with jumper cables."),(0,a.yg)("li",{parentName:"ul"},"4 x momentary switches"),(0,a.yg)("li",{parentName:"ul"},"4 x 220\u03a9 pull-up resistors for the switches.")),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"Schematic",src:t(7561).A})),(0,a.yg)("h2",{id:"setting-up"},"Setting up"),(0,a.yg)("p",null,"We'll be using the Arduino IDE to program the device."),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"The Arduino IDE is available from ",(0,a.yg)("a",{parentName:"li",href:"https://www.arduino.cc/en/Main/Software#download"},"here"),"."),(0,a.yg)("li",{parentName:"ul"},"To get your board setup with Arduino IDE I recommend following a guide like\n",(0,a.yg)("a",{parentName:"li",href:"http://www.instructables.com/id/Quick-Start-to-Nodemcu-ESP8266-on-Arduino-IDE/"},"this one"),"\nand try to load up an example sketch like Blink."),(0,a.yg)("li",{parentName:"ul"},"For OSX Yosemite I needed to install the CH340G driver available from\n",(0,a.yg)("a",{parentName:"li",href:"http://kig.re/2014/12/31/how-to-use-arduino-nano-mini-pro-with-CH340G-on-mac-osx-yosemite.html"},"here"),"."),(0,a.yg)("li",{parentName:"ul"},"With the board now setup, go to ",(0,a.yg)("inlineCode",{parentName:"li"},"Sketch > Include Library > Manage Libraries..."),"\nand search for the ArduinoJson, then click on Install.")),(0,a.yg)("p",null,"Go to ",(0,a.yg)("inlineCode",{parentName:"p"},"File -> New")," to create a new sketch.\nThe empty sketch defines two functions:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"setup()")," contains initialization code that is run once when the board is powered on."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"loop()")," is run repeatedly until the device is switched off.")),(0,a.yg)("p",null,"To make debugging easier, we can enable debugging over a serial connection."),(0,a.yg)("p",null,"To do so, simply add the following to the ",(0,a.yg)("inlineCode",{parentName:"p"},"setup()")," function:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"Serial.begin(115200);\n")),(0,a.yg)("p",null,"and open ",(0,a.yg)("inlineCode",{parentName:"p"},"Tools > Serial Monitor")," to see any output generated."),(0,a.yg)("h2",{id:"reading-the-button-state"},"Reading the button state"),(0,a.yg)("p",null,"To start with, we'll write some code to read the button inputs, allowing us to\nrespond to button presses when they occur."),(0,a.yg)("p",null,"First we'll declare some variables to store state."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"// the four digital inputs connected to momentary switches\nconst int btn0 = D0;\nconst int btn1 = D1;\nconst int btn2 = D2;\nconst int btn3 = D3;\n\n// the last read state of each button where\n// true  --\x3e pressed\n// false --\x3e not pressed\nbool btnState0, btnState1, btnState2, btnState3;\n")),(0,a.yg)("p",null,"We also need to initialize the pins as inputs before we read:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"void setup() {\n    // for debug logging\n    Serial.begin(115200);\n\n    // initialize buttons\n    pinMode(btn0, INPUT);\n    pinMode(btn1, INPUT);\n    pinMode(btn2, INPUT);\n    pinMode(btn3, INPUT);\n\n    // initial button state\n    btnState0 = btnState1 = btnState2 = btnState3 = false;\n}\n")),(0,a.yg)("p",null,"Now in ",(0,a.yg)("inlineCode",{parentName:"p"},"loop()")," we can use the function ",(0,a.yg)("inlineCode",{parentName:"p"},"checkBtn")," to check the state of each of the buttons."),(0,a.yg)("p",null,"The variable ",(0,a.yg)("inlineCode",{parentName:"p"},"readDelayMs")," defines the amount of time between readings in\nmilliseconds."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'const int readDelayMs = 100;\n\nvoid loop() {\n    checkBtn(btn0, btnState0, "inventory/cola");\n    checkBtn(btn1, btnState1, "inventory/beer");\n    checkBtn(btn2, btnState2, "inventory/water");\n    checkBtn(btn3, btnState3, "inventory/apfelschorle");\n\n    delay(readDelayMs);\n}\n\nvoid checkBtn(\n    const int btn, // the pin that the button is connected to\n    bool &btnState, // the current state of the button\n    char *recordName // the name of the record we will update\n    ) {\n    if (digitalRead(btn) == LOW && !btnState) {\n        // button pressed\n        Serial.printf("Button pressed: %s\\n", recordName);\n        btnState = true;\n    } else if (digitalRead(btn) == HIGH && btnState) {\n        // button released\n        Serial.printf("Button released: %s\\n", recordName);\n        btnState = false;\n    }\n}\n')),(0,a.yg)("p",null,"If you build and upload the script now and look in the ",(0,a.yg)("inlineCode",{parentName:"p"},"Serial Monitor")," window\nyou should see log lines, with the value changing as the light level changes e.g."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"Button pressed: inventory/water\nButton released: inventory/water\nButton pressed: inventory/beer\nButton released: inventory/beer\n")),(0,a.yg)("h2",{id:"connecting-to-wifi"},"Connecting to WiFi"),(0,a.yg)("p",null,"To submit this data to deepstream we'll need an internet connection, so\nwe'll include the necessary libraries to use the device's WiFi chip:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"#include <ESP8266WiFiMulti.h>\n#include <ESP8266HTTPClient.h>\n")),(0,a.yg)("p",null,"Now we need to initialize the WiFi client, and wait for the connection to be\nsetup:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'ESP8266WiFiMulti WiFiMulti;\n\nconst char* ssid = "YOUR_NETWORK_SSID";\nconst char* password = "YOUR_NETWORK_PASSWORD";\n\nvoid setup() {\n    // ...\n\n    // connect to WiFi\n    WiFiMulti.addAP(ssid, password);\n}\n\nvoid loop() {\n    if (WiFiMulti.run() != WL_CONNECTED) {\n      delay(200);\n      Serial.print("."); // indicate that device is still connecting\n      return;\n    }\n\n    // ...\n}\n')),(0,a.yg)("h2",{id:"building-a-request"},"Building a request"),(0,a.yg)("p",null,"Each time a button is pressed we would like the corresponding value (stored in\na ",(0,a.yg)("a",{parentName:"p",href:"../../tutorials/core/datasync/records/"},"record"),") to be decremented. That requires a read\n(to get the current state) followed by a write to set the new value."),(0,a.yg)("p",null,"You should also select the relevant TLS fingerprint below that relates to the\nsubdomain in your HTTP URL."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'const char* deepstreamHttpUrl = "<YOUR HTTP URL>";\n/*\n * TLS fingerprints:\n *\n * 013.deepstream.com: "3A:FC:6E:78:94:18:C0:A2:36:F3:C7:DF:86:27:4B:5A:CA:CF:28:3F"\n * 035.deepstream.com: "57:18:5A:22:07:94:03:EF:90:C9:C2:56:58:C9:BB:06:66:A6:EA:76"\n * 154.deepstream.com: "3C:65:CA:7C:3F:43:2D:FF:A1:63:38:F3:23:D5:59:25:E4:85:8C:0F"\n */\nconst char* deepstreamTlsFingerprint = "<YOUR HTTP DOMAIN FINGERPRINT>";\n')),(0,a.yg)("p",null,"Using the HTTP API is very similar for record reads and writes, so let's write\na function that can do both called ",(0,a.yg)("inlineCode",{parentName:"p"},"recordRequest"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <ArduinoJson.h> // a library for parsing and serializing JSON objects\n\n// the possible record actions\nenum class RecordAction { Read, Write, Head };\n\n// make an HTTP request to read or write a record\nJsonVariant recordRequest(RecordAction action, char *recordName, char *path = nullptr, JsonVariant data = {}) {\n    HTTPClient http;\n\n    // configure client\n    http.begin(deepstreamHttpUrl, deepstreamTlsFingerprint);\n\n    // set content type\n    http.addHeader("Content-Type", "application/json");\n\n    // create message body\n    jsonBuffer.clear();\n    JsonObject& root = jsonBuffer.createObject();\n    JsonArray& body = root.createNestedArray("body");\n    JsonObject& message = body.createNestedObject();\n    message["topic"] = "record";\n\n    switch (action) {\n        case RecordAction::Read:\n            message["action"] = "read";\n            break;\n        case RecordAction::Head:\n            message["action"] = "head";\n            break;\n        case RecordAction::Write:\n            message["action"] = "write";\n            // only writes have a payload\n            if (path != nullptr) {\n                message["path"] = "amount";\n            }\n            message["data"] = data;\n            break;\n        default:\n            Serial.printf("Unknown record action %d\\n", static_cast<int>(action));\n    }\n\n    message["recordName"] = recordName;\n\n    // copy object into array\n    size_t requestBodySize = root.measureLength() + 1;\n    char requestBody[requestBodySize];\n    root.printTo(requestBody, requestBodySize);\n\n    // log request\n    Serial.print("request: ");\n    root.printTo(Serial);\n    Serial.println();\n\n    // make request\n    int httpCode = http.POST(requestBody);\n\n    int result = -1;\n    if(httpCode == HTTP_CODE_OK) {\n        // parse response\n        String payload = http.getString();\n        jsonBuffer.clear();\n        JsonObject& resp = jsonBuffer.parseObject(payload);\n        if (!resp.success()) {\n            // failed to parse JSON response\n            Serial.printf("Failed to parse response: %s\\n", payload.c_str());\n        } else if (!resp["body"][0]["success"]) {\n            // failed to update record\n            Serial.printf("Record update error: %s\\n", resp["body"][0]["error"]);\n        } else {\n            // record update success\n            Serial.println("Record was updated successfully!");\n            result = resp["body"][0]["data"];\n        }\n    } else if (httpCode < 0) {\n        // handle HTTP client error\n        Serial.printf("Request failed, error: %s\\n", http.errorToString(httpCode).c_str());\n    } else {\n        // handle HTTP error response\n        Serial.printf("Error response %d: %s\\n", httpCode, http.getString().c_str());\n    }\n\n    http.end();\n    return result;\n}\n')),(0,a.yg)("p",null,"Finally we can add a short function ",(0,a.yg)("inlineCode",{parentName:"p"},"decRecord")," that simply reads the current\nstate of the record, increments the ",(0,a.yg)("inlineCode",{parentName:"p"},"amount")," parameter, and writes it back:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'void checkBtn(const int btn, bool &btnState, char *recordName) {\n    // ...\n    } else if (digitalRead(btn) == HIGH && btnState) {\n        // button released\n        btnState = false;\n        decRecord(recordName);\n    }\n}\n\nvoid decRecord(char *recordName) {\n    JsonVariant recordData = recordRequest(RecordAction::Read, recordName);\n    if (!recordData.is<JsonObject>()) {\n        Serial.println("Decrement aborted");\n        return;\n    }\n    int amount = recordData["amount"];\n    Serial.printf("Record read: %d\\n", amount);\n    amount--;\n    recordRequest(RecordAction::Write, recordName, "amount", amount);\n}\n')),(0,a.yg)("p",null,"We have to create a new ",(0,a.yg)("inlineCode",{parentName:"p"},"HTTPClient")," for each message, so we'll create that in\n",(0,a.yg)("inlineCode",{parentName:"p"},"updateRecord()")," and make sure it's closed after."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"HTTPClient http;\n\n// configure client\nhttp.begin(deepstreamHttpUrl, deepstreamTlsFingerprint);\n\n// ...\n\nhttp.end();\n")),(0,a.yg)("p",null,"The deepstream HTTP API uses a JSON payload, so to help us build that we'll\ninclude the ",(0,a.yg)("inlineCode",{parentName:"p"},"ArduinoJSON")," library we installed earlier."),(0,a.yg)("p",null,"The body we're creating needs to look like this:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "topic": "record",\n  "action": "read",\n  "recordName": "inventory/beer"\n}\n')),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "topic": "record",\n  "action": "write",\n  "recordName": "inventory/beer",\n  "path": "amount",\n  "data": 25\n}\n')),(0,a.yg)("p",null,"Here's the code to do that:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'#include <ArduinoJson.h>\n\nvoid updateRecord(int level) {\n    // ...\n\n    // create message body\n    StaticJsonBuffer<200> bodyBuff;\n    JsonObject& root = bodyBuff.createObject();\n    JsonArray& body = root.createNestedArray("body");\n    JsonObject& message = body.createNestedObject();\n    message["topic"] = "record";\n    message["action"] = "write";\n    message["recordName"] = "readings/light-level";\n    message["path"] = "value";\n    message["data"] = level;\n\n    // copy object into array\n    size_t bodySize = bodyBuff.size();\n    char requestBody[bodySize];\n    root.printTo(requestBody, bodySize);\n}\n')),(0,a.yg)("p",null,"Now let's put this in a POST request:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'void updateRecord(int level) {\n    // ...\n\n    // set content type\n    http.addHeader("Content-Type", "application/json");\n\n    // make request\n    int httpCode = http.POST(requestBody);\n}\n')),(0,a.yg)("h2",{id:"handling-failure"},"Handling failure"),(0,a.yg)("p",null,"There are three main ways the record update could fail:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The request could fail e.g. a connection error\nIn this case ",(0,a.yg)("inlineCode",{parentName:"p"},"httpCode")," will be negative.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The request could fail to parse or authenticate on the server.\nIn this case ",(0,a.yg)("inlineCode",{parentName:"p"},"httpCode")," will be a 4xx response.")),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("p",{parentName:"li"},"The record update could fail e.g. the Valve permissions to not allow writes\nIn this case ",(0,a.yg)("inlineCode",{parentName:"p"},"httpCode")," will be 200, but the JSON response will indicate a failure."))),(0,a.yg)("p",null,"Let's handle those and log the outcome:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'void updateRecord(int level) {\n    // ...\n\n    if(httpCode == HTTP_CODE_OK) {\n        // parse response\n        String payload = http.getString();\n        StaticJsonBuffer<200> respBuff;\n        JsonObject& resp = respBuff.parseObject(payload);\n        if (!resp["body"][0]["success"]) {\n            // failed to update record\n            Serial.printf("Record update error: %s\\n", resp["body"][0]["error"]);\n            return;\n        }\n        // record update success\n        Serial.println("Record was updated successfully!");\n    } else if (httpCode < 0) {\n        Serial.printf("Request failed, error: %s\\n", http.errorToString(httpCode).c_str());\n    } else {\n        Serial.printf("Error response %d: %s\\n", httpCode, http.getString().c_str());\n    }\n}\n')),(0,a.yg)("p",null,"Now let's set up the green LED to flash if the update is successful, the red LED otherwise:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'const int greenLed = D1;\nconst int redLed = D2;\n\nvoid setup() {\n    // ...\n\n    // initialize LEDs\n    pinMode(redLed, OUTPUT);\n    pinMode(greenLed, OUTPUT);\n    digitalWrite(redLed, LOW);\n    digitalWrite(greenLed, LOW);\n}\n\nvoid flashLed(int led) {\n    digitalWrite(led, HIGH);\n    delay(500);\n    digitalWrite(led, LOW);\n}\n\nvoid updateRecord(int level) {\n    // httpCode will be negative on error\n    if(httpCode == HTTP_CODE_OK) {\n        // parse payload\n        // ...\n        if (!resp["body"][0]["success"]) {\n            // failed to update record\n            Serial.printf("Record update error: %s\\n", resp["body"][0]["error"]);\n            flashLed(redLed);\n            return;\n        }\n        // record update success\n        Serial.println("Record was updated successfully!");\n        flashLed(greenLed);\n    } else if (httpCode < 0) {\n        Serial.printf("Request failed, error: %s\\n", http.errorToString(httpCode).c_str());\n        flashLed(redLed);\n    } else {\n        Serial.printf("Error response %d: %s\\n", httpCode, http.getString().c_str());\n        flashLed(redLed);\n    }\n}\n')))}c.isMDXComponent=!0}}]);